const Pt = (n, r) => {
  let F = !0;
  const P = { x: 0, y: 0 }, f = { x: 0, y: 0 }, u = { x: 0, y: 0 }, A = new Proxy(
    { x: 0, y: 0 },
    {
      set(t, e, i) {
        return t[e] === i || (t[e] = i, (t.x >= 10 || t.y >= 10) && L(!0)), !0;
      }
    }
  ), l = new Proxy(
    { x: !1, y: !1 },
    {
      set(t, e, i) {
        return t[e] === i || (t[e] = i, t.x || t.y ? (n.setAttribute("has-overflow", "true"), n.addEventListener("pointerdown", tt), n.addEventListener("wheel", it, { passive: !1 })) : (n.removeAttribute("has-overflow"), n.removeEventListener("pointerdown", tt), n.removeEventListener("wheel", it))), !0;
      }
    }
  );
  let x = 300, y = null, d = !1, h = 300, p = 300, z = 300, K = 300;
  const B = { start: 0, end: 0 }, D = { start: 0, end: 0 };
  let O = [], b = null, C = null, k = null, R = !1, W, v = 1, w = { target: null, x: 0 };
  function ct() {
    n == null || n.setAttribute("blossom-carousel", "true"), b = (n == null ? void 0 : n.querySelectorAll("a[href]")) || null, b == null || b.forEach((i) => {
      i.addEventListener("click", J);
    }), window.addEventListener("keydown", at), n.addEventListener("scroll", Z), C = new ResizeObserver(Q), C.observe(n), k = new MutationObserver(pt), k.observe(n, {
      attributes: !1,
      childList: !0,
      subtree: !1
    });
    const t = window.matchMedia(
      "(hover: hover) and (pointer: fine)"
    ).matches;
    v = n.closest('[dir="rtl"]') ? -1 : 1;
    const { scrollSnapType: e } = window.getComputedStyle(n);
    R = e !== "none", n.style.setProperty("--snap-type", e), t && (n.style["scroll-snap-type"] = "none"), n.setAttribute("has-repeat", r != null && r.repeat ? "true" : "false"), W = mt((i) => {
      (i === n || n.contains(i)) && L(!1);
    });
  }
  function dt() {
    n.removeAttribute("blossom-carousel"), C == null || C.disconnect(), k == null || k.disconnect(), y && cancelAnimationFrame(y), window.removeEventListener("keydown", at), n.removeEventListener("scroll", Z), b == null || b.forEach((t) => {
      t.removeEventListener("click", J);
    }), W == null || W();
  }
  function J(t) {
    A.x > 10 && t.preventDefault();
  }
  function Q() {
    if (!n) return;
    const t = "ontouchmove" in window;
    h = n.scrollWidth, p = n.clientWidth, z = n.scrollHeight, K = n.clientHeight;
    const e = window.getComputedStyle(n);
    l.x = !t && h > p && ["auto", "scroll"].includes(e.getPropertyValue("overflow-x")), l.y = !t && z > K && ["auto", "scroll"].includes(e.getPropertyValue("overflow-y")), B.end = parseInt(e.paddingInlineEnd) || 0, B.start = parseInt(e.paddingInlineStart) || 0, D.start = parseInt(e.scrollPaddingInlineStart) || 0, D.end = parseInt(e.scrollPaddingInlineEnd) || 0, v = n.closest('[dir="rtl"]') ? -1 : 1, x = (h - p - 4) * v, O = R ? ht(n) : [], r != null && r.repeat && H(null, null);
  }
  function pt() {
    Q();
  }
  function ht(t) {
    let e = [], i = 0;
    const s = (o) => {
      if (i++, i > 100) return;
      const c = window.getComputedStyle(o).scrollSnapAlign;
      if (c !== "none") {
        e.push({
          align: c,
          el: o
        });
        return;
      }
      const m = o.children;
      if (m.length !== 0)
        for (let V of m)
          s(V);
    };
    s(t);
    const N = t.getBoundingClientRect();
    return e.map(({ el: o, align: E }, c) => {
      const m = o.getBoundingClientRect(), V = o.clientWidth, j = m.left - N.left + t.scrollLeft;
      switch (E) {
        case "start":
          return { target: o, x: j - D.start };
        case "end":
          return {
            target: o,
            x: j + V - p + D.end
          };
        case "center":
          return {
            target: o,
            x: j + V * 0.5 - p / 2
          };
        default:
          return null;
      }
    }).filter((o) => o !== null).reduce((o, E) => ((o.length === 0 || o[o.length - 1].x !== E.x) && o.push(E), o), []);
  }
  function Z() {
    if (r != null && r.repeat) {
      H(null, null);
      return;
    }
    if (d || !n) return;
    const t = n.scrollLeft;
    if (t < 0) {
      const e = t * -1;
      $(e);
    } else if (t > h - p) {
      const e = t * -1 + h - p;
      $(e);
    }
  }
  const a = {
    x: 0,
    y: 0
  };
  function tt(t) {
    n && (l.x && (a.x = n.scrollLeft, P.x = t.clientX, u.x = 0), l.y && (a.y = n.scrollTop, P.y = t.clientY, u.y = 0), A.x = 0, d = !0, window.addEventListener("pointermove", nt), window.addEventListener("pointerup", et));
  }
  function nt(t) {
    if (t.preventDefault(), l.x) {
      const e = P.x - t.clientX;
      f.x += e, u.x += e, P.x = t.clientX, A.x += Math.abs(e);
    }
    if (l.y) {
      const e = P.y - t.clientY;
      f.y += e, u.y += e, P.y = t.clientY, A.y += Math.abs(e);
    }
  }
  function et() {
    window.removeEventListener("pointermove", nt), window.removeEventListener("pointerup", et), d = !1, !(A.x <= 10) && (l.x && (u.x *= 2), l.y && (u.y *= 2), xt(), St());
  }
  function it(t) {
    if (Math.abs(t.deltaX) > Math.abs(t.deltaY)) {
      if (L(!1), d || !n) return;
      l.x && (a.x = n.scrollLeft), l.y && (a.y = n.scrollTop);
    }
  }
  function at(t) {
    ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(t.key) && L(!1);
  }
  function xt() {
    const t = ft({ axis: "x" });
    t.x !== w.x && lt(t), w = t;
    const s = (ut(
      t.x,
      Math.min((h - p) * v, 0),
      Math.max((h - p) * v, 0)
    ) - f.x) * (1 - S) * (1 / S);
    u.x = s;
  }
  function H(t, e) {
    if (!n) return;
    const i = e ?? n.scrollLeft, s = B.start - i, N = i - (h - p - B.end), g = Array.from(n.children);
    let U = 0;
    for (let c = g.length - 1; c >= g.length / 2; c--) {
      const m = U > s ? 0 : -(h - p);
      U += g[c].clientWidth, g[c].style.translate = `${m}px 0`;
    }
    let o = 0;
    for (let c = 0; c < g.length / 2; c++) {
      const m = o > N ? 0 : h - p;
      o += g[c].clientWidth, g[c].style.translate = `${m}px 0`;
    }
    if (d) return;
    const E = i > x ? 4 : i < 4 ? x : null;
    E && (T = !0, n.scrollTo({
      left: E,
      behavior: "instant"
    }));
  }
  function ot(t) {
    q && t.stopPropagation();
  }
  const S = 0.72, Y = 0.12;
  let q = !1;
  function L(t) {
    n && (t && !q ? (_ = performance.now(), l.x && (f.x = n.scrollLeft), l.y && (f.y = n.scrollTop), n.addEventListener("scrollend", ot, {
      capture: !0,
      passive: !1
    }), y || (y = requestAnimationFrame(st))) : t || (y && cancelAnimationFrame(y), y = null, n.removeEventListener("scrollend", ot)), q = t, F = !t, n.setAttribute("has-snap", F ? "true" : "false"));
  }
  let M = 0, _ = 0;
  function st(t) {
    if (y = requestAnimationFrame(st), M = t - _, !!n) {
      if (l.x && (u.x *= S, d ? a.x = X(a.x, f.x, S, M) : (f.x += u.x, a.x = X(a.x, f.x, Y, M))), l.y && (u.y *= S, d ? a.y = X(a.y, f.y, S, M) : (f.y += u.y, a.y = X(a.y, f.y, Y, M))), r != null && r.repeat && (a.x > x && (a.x = f.x = 4), a.x < 4 && (a.x = f.x = x)), T = !0, n.scrollTo({
        left: a.x,
        top: a.y,
        behavior: "instant"
      }), d && R) {
        const e = ft({ axis: "x" });
        e.x !== w.x && (w = e, lt(e));
      }
      !d && G(u.x, 8) === 0 && (L(!1), vt(), R && wt()), r != null && r.repeat ? H(null, a.x) : yt(G(a.x, 2)), _ = t;
    }
  }
  let I = 0;
  function yt(t) {
    if (!n) return;
    const e = x;
    let i = 0;
    if (t * v <= 0 ? i = d ? t * -0.2 : 0 : t * v > e * v && (i = d ? (t - e) * -0.2 : 0), I = X(
      I,
      i,
      d ? 0.8 : Y,
      M
    ), Math.abs(I) > 0.01) {
      if ($(I).defaultPrevented) return;
      n.style.transform = `translateX(${G(I, 3)}px)`;
      return;
    }
    n.style.transform = "", I = 0;
  }
  function $(t) {
    const e = new CustomEvent("overscroll", {
      bubbles: !0,
      cancelable: !0,
      detail: { left: t }
    });
    return n == null || n.dispatchEvent(e), e;
  }
  const rt = new Event("scrollend", {
    bubbles: !0,
    cancelable: !0
  });
  function vt() {
    return n == null || n.dispatchEvent(rt), rt;
  }
  function wt() {
    const t = new CustomEvent("scrollsnapchange", {
      bubbles: !0,
      cancelable: !0,
      detail: {
        snapTargetInline: w.target,
        snapTargetBlock: w.target
      }
    });
    return n == null || n.dispatchEvent(t), t;
  }
  function lt(t) {
    const e = new CustomEvent("scrollsnapchanging", {
      bubbles: !0,
      cancelable: !0,
      detail: {
        snapTargetInline: (t || w).target,
        snapTargetBlock: (t || w).target
      }
    });
    return n == null || n.dispatchEvent(e), e;
  }
  let T = !1;
  const gt = n.scrollTo.bind(n);
  n.scrollTo = function(t) {
    T === !0 || L(!1), T = !1, gt(t);
  };
  const Et = n.scrollBy.bind(n);
  n.scrollBy = function(t) {
    T === !0 || L(!1), T = !1, Et(t);
  };
  function mt(t) {
    const e = [], i = Element.prototype.scrollIntoView;
    return i && (Element.prototype.scrollIntoView = function(s) {
      return t(this, "scrollIntoView", [s]), i.call(this, s);
    }, e.push(() => {
      Element.prototype.scrollIntoView = i;
    })), () => e.forEach((s) => s());
  }
  function bt({ axis: t = "x" }) {
    return f[t] + u[t] / (1 - S);
  }
  function ft({ axis: t = "x" }) {
    const e = bt({ axis: t });
    return O.length ? O.reduce(
      (i, s) => Math.abs(s.x - e) < Math.abs(i.x - e) ? s : i
    ) : {
      target: null,
      x: ut(e, Math.min(x, 0), Math.max(x, 0))
    };
  }
  function St() {
    const t = (e) => {
      e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", t, !0);
    };
    window.addEventListener("click", t, !0);
  }
  function Lt(t, e, i) {
    return (1 - i) * t + i * e;
  }
  function X(t, e, i, s) {
    return Lt(t, e, 1 - Math.exp(Math.log(1 - i) * (s / 16.666666666666668)));
  }
  function ut(t, e, i) {
    return t < e ? e : t > i ? i : t;
  }
  function G(t, e = 0) {
    const i = Math.pow(10, e);
    return Math.round(t * i) / i;
  }
  return {
    snap: F,
    hasOverflow: l,
    init: ct,
    destroy: dt
  };
};
export {
  Pt as Blossom
};
